<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swara → Music • V1.1 (Stability Fix)</title>
  <style>
    :root{--bg:#0b0f14;--card:#121823;--muted:#9fb0c0;--text:#e9f0f6;--accent:#7cc4ff;--accent-2:#a5ffd6;--danger:#ff8a8a}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b0f14,#0d1520);color:var(--text);}
    .wrap{max-width:1000px;margin:24px auto;padding:0 16px;}
    h1{font-size:28px;margin:0 0 10px;letter-spacing:0.5px}
    p.sub{margin:0 0 18px;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid #162030;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    .card h2{font-size:16px;margin:0;padding:14px 16px;border-bottom:1px solid #1a2736;color:#cfe6ff}
    .card .content{padding:14px 16px}
    textarea{width:100%;min-height:140px;background:#0e1420;color:var(--text);border:1px solid #1b2a3d;border-radius:12px;padding:12px;font-size:14px;resize:vertical}
    label{display:block;font-size:12px;letter-spacing:.4px;color:#c3d0db;margin:10px 0 6px;text-transform:uppercase}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    select,input[type="number"],input[type="text"]{background:#0e1420;border:1px solid #1b2a3d;border-radius:10px;color:var(--text);padding:10px 12px;font-size:14px}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{appearance:none;border:none;border-radius:999px;padding:10px 16px;font-weight:600;cursor:pointer}
    .primary{background:linear-gradient(135deg,var(--accent),#58a9ff);color:#021018}
    .secondary{background:#16243a;color:#cfe6ff;border:1px solid #223759}
    .danger{background:var(--danger);color:#2b0000}
    .pill{display:inline-block;background:#0f1a2a;border:1px solid #21324a;color:#cfe6ff;padding:6px 10px;border-radius:999px;margin:4px 6px 0 0;font-size:12px}
    .muted{color:var(--muted)}
    .log{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;line-height:1.4;white-space:pre-wrap;background:#0a0f18;border:1px dashed #1d2a3e;border-radius:12px;padding:12px;color:#d4e1ee}
    .footer{font-size:12px;color:#95a6b8;margin-top:22px}
    .badge{display:inline-flex;align-items:center;gap:6px;background:#0f1a2a;border:1px solid #1f2c42;border-radius:999px;padding:6px 10px;color:#bfe4ff;font-size:12px}
    .mini{font-size:11px;color:#98aec2}
    .examples{display:flex;flex-wrap:wrap;gap:8px}
    .examples button{background:#0f1a2a;border:1px solid #1f2c42;color:#cfe6ff}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Swara → Music • V1.1</h1>
    <p class="sub">Stability pass: numeric sanitization + error‑token skipping + basic tests. Still offline, no libraries. 12‑TET via <span class="badge">Web Audio API</span>.</p>

    <div class="grid">
      <!-- Left: Editor -->
      <div class="card">
        <h2>Sequence</h2>
        <div class="content">
          <label for="seq">Swaras (see syntax below)</label>
          <textarea id="seq" placeholder="Example: S R G M P D N S' | S' N D P M G R S"></textarea>

          <div class="examples">
            <button id="ex1">Pentatonic demo</button>
            <button id="ex2">Komal notes demo</button>
            <button id="ex3">Durations demo</button>
          </div>

          <div class="row">
            <div>
              <label for="saNote">Sa (Tonic)</label>
              <select id="saNote"></select>
            </div>
            <div>
              <label for="saOct">Octave</label>
              <select id="saOct">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4" selected>4</option>
                <option value="5">5</option>
              </select>
            </div>
            <div>
              <label for="bpm">Tempo (BPM)</label>
              <input id="bpm" type="number" min="30" max="240" value="96" />
            </div>
            <div>
              <label for="wave">Timbre</label>
              <select id="wave">
                <option value="sine">Sine</option>
                <option value="triangle" selected>Triangle</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div>
              <label for="attack">Attack (s)</label>
              <input id="attack" type="number" min="0" max="1" step="0.01" value="0.02" />
            </div>
            <div>
              <label for="release">Release (s)</label>
              <input id="release" type="number" min="0" max="2" step="0.01" value="0.12" />
            </div>
            <div>
              <label for="gain">Gain</label>
              <input id="gain" type="number" min="0" max="1" step="0.01" value="0.25" />
            </div>
          </div>

          <div class="btns">
            <button class="primary" id="play">▶ Play</button>
            <button class="secondary" id="stop">■ Stop</button>
            <button class="secondary" id="showParsed">Show parsed</button>
            <button class="secondary" id="copyWestern">Copy Western notes</button>
            <button class="secondary" id="runTests">Run tests</button>
            <button class="danger" id="clear">Clear</button>
          </div>

          <p class="mini" style="margin-top:10px"><strong>Syntax:</strong> Uppercase = shuddha (R,G,D,N). Lowercase = komal (r,g,d,n). Tivra Ma = <code>M#</code>. Octave: <code>S'</code> higher, <code>S.</code> lower (repeat ' or . for multiple octaves). Duration in beats: append a number e.g., <code>G2</code> = 2 beats. Use spaces or <code>|</code> as separators. Rests: <code>_</code> (underscore), e.g., <code>_2</code> for two beats rest.</p>
        </div>
      </div>

      <!-- Right: Output / Help -->
      <div class="card">
        <h2>Parsed / Log</h2>
        <div class="content">
          <div id="status" class="pill">Ready</div>
          <pre id="log" class="log" style="margin-top:10px"></pre>
          <div class="footer">
            <div><strong>Mapping</strong>: S(0), r(1), R(2), g(3), G(4), M(5), M#(6), P(7), d(8), D(9), n(10), N(11).</div>
            <div>Engine: Web Audio API. Tuning: A4=440, 12‑TET. Sa is aligned to selected Western pitch.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// ===== Utility: Western notes and tuning =====
var WEST_NOTES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
function clamp(v, min, max){ v = Number(v); if(!Number.isFinite(v)) return min; if(v < min) return min; if(v > max) return max; return v; }
function safeNumber(v, fallback){ v = Number(v); return Number.isFinite(v) ? v : fallback; }
function isFiniteNumber(v){ return typeof v === 'number' && Number.isFinite(v); }

function midiFromNoteName(name, octave){
  // name like "C#", octave like 4. MIDI 69 = A4
  var nIndex = WEST_NOTES.indexOf(String(name || "").toUpperCase());
  var oct = safeNumber(octave, 4);
  if(nIndex < 0){ return 60; } // fallback to C4
  return (oct + 1)*12 + nIndex; // MIDI formula
}
function freqFromMidi(m){
  if(!isFiniteNumber(m)) return NaN;
  return 440 * Math.pow(2, (m - 69)/12);
}

// ===== Swara mapping (relative semitones from Sa) =====
var SWARA_MAP = {
  "S": 0,
  "r": 1, // komal Re
  "R": 2, // shuddha Re
  "g": 3, // komal Ga
  "G": 4, // shuddha Ga
  "M": 5, // shuddha Ma
  "M#": 6, // tivra Ma
  "P": 7,
  "d": 8, // komal Dha
  "D": 9, // shuddha Dha
  "n": 10, // komal Ni
  "N": 11 // shuddha Ni
};

// ===== Parser =====
function expandGroups(text) {
  // Handle repetitions like "SRMP x3"
  text = text.replace(/([A-Za-z#.'0-9()]+)\s*x(\d+)/g, function(_, seq, count) {
    var arr = [];
    for (var i = 0; i < parseInt(count, 10); i++) {
      arr.push(seq);
    }
    return arr.join(" ");
  });

  // Handle parenthesis groups like (SRGM) -> S R G M with fractional beats
  text = text.replace(/\(([^\)]+)\)/g, function(_, inner) {
    var notes = inner.trim().split("");
    var frac = 1.0 / notes.length;
    return notes.map(function(n) { return n + "["+frac+"]"; }).join(" ");
  });

  return text;
}


// ----------------- Tokenizer (used by parseSequence + showParsed) -----------------
function tokenizeForParse(text){
  if(!text) return [];
  // normalize whitespace but keep characters intact
  var s = text.replace(/\n/g,' ').trim();
  var tokens = [];
  var i = 0;
  while(i < s.length){
    var ch = s[i];
    // whitespace
    if(/\s/.test(ch)){ i++; continue; }
    // pipe
    if(ch === '|'){ tokens.push('|'); i++; continue; }
    // parenthesis group: capture until matching ')' (no deep nesting support)
    if(ch === '('){
      var j = i + 1;
      var depth = 1;
      while(j < s.length && depth > 0){
        if(s[j] === '(') depth++;
        else if(s[j] === ')') depth--;
        if(depth > 0) j++;
      }
      // j is at index of ')' or end
      var inner = s.slice(i+1, (j < s.length ? j : s.length));
      var k = (j < s.length ? j+1 : j);
      // optional duration digits right after ')'
      var durMatch = s.slice(k).match(/^([0-9]{1,2})/);
      var dur = '';
      if(durMatch){ dur = durMatch[1]; k += dur.length; }
      // optional attached repetition xN right after
      var repMatch = s.slice(k).match(/^x([0-9]{1,3})/i);
      var rep = '';
      if(repMatch){ rep = 'x' + repMatch[1]; k += repMatch[0].length; }
      var token = '(' + inner + ')' + dur + rep;
      tokens.push(token);
      i = k;
      continue;
    }
    // rest token starting with underscore
    if(ch === '_'){
      var j = i+1; var digits = '';
      while(j < s.length && /[0-9]/.test(s[j])){ digits += s[j]; j++; }
      tokens.push('_' + digits);
      i = j;
      continue;
    }
    // other runs (letters, octave marks, digits, attached xN) until whitespace or | or (
    var j = i; var tok = '';
    while(j < s.length && !/\s|\(|\)|\|/.test(s[j])){
      tok += s[j];
      j++;
    }
    tokens.push(tok);
    i = j;
  }
  return tokens;
}

// ----------------- parseSequence (full, robust) -----------------
function parseSequence(text){
  // Returns array of {token, isRest, base, offset, octaveShift, beats, error?}
  var out = [];
  if(!text){ return out; }

  var BASE_RE = /^(M#|S|r|R|g|G|M|P|d|D|n|N)/; // M# must come before M

  function cloneNote(n){
    return {
      token: n.token,
      isRest: !!n.isRest,
      base: n.base,
      offset: n.offset,
      octaveShift: n.octaveShift,
      beats: n.beats,
      error: n.error
    };
  }

  function makeErrorToken(orig, msg){
    return { token: orig, error: msg };
  }

  function parseSingleTokenStr(tok){
    // tok could be like "S", "G2", "R'", "M#.", "g2", etc.
    var s = (tok || "").replace(/m#/g,'M#');
    var mBase = s.match(BASE_RE);
    if(!mBase){ return { error: "Unknown token" }; }
    var base = mBase[1];
    var rest = s.slice(base.length);

    // count octave up (') then octave down (.) in order
    var upCount = 0;
    var i = 0;
    while(i < rest.length && rest[i] === "'"){ upCount++; i++; }
    var downCount = 0;
    while(i < rest.length && rest[i] === '.'){ downCount++; i++; }
    // remaining part may contain digits for beats; capture trailing digits
    var trailing = rest.slice(i);
    var mBeats = trailing.match(/([0-9]{1,2})$/);
    var beats = 1;
    if(mBeats){ beats = parseInt(mBeats[1],10); if(!Number.isFinite(beats) || beats < 0) beats = 1; }

    var offset = SWARA_MAP[base];
    if(typeof offset === 'undefined'){ return { error: "Unsupported swara" }; }

    var tokenOut = base + (upCount ? "'".repeat(upCount) : "") + (downCount ? ".".repeat(downCount) : "");
    return { base: base, offset: offset, octaveShift: upCount - downCount, beats: beats, token: tokenOut };
  }

  function parseRunString(runStr){
    // parse concatenated run like "SRGM" or "S'R.G" into items array
    var s = (runStr || "").replace(/m#/g,'M#');
    var items = [];
    var p = 0;
    while(p < s.length){
      var substr = s.slice(p);
      var mBase = substr.match(BASE_RE);
      if(!mBase){ return { error: "Unknown run content" }; }
      var base = mBase[1];
      p += base.length;

      // count octave up (') and down (.)
      var upCount = 0;
      while(p < s.length && s[p] === "'"){ upCount++; p++; }
      var downCount = 0;
      while(p < s.length && s[p] === '.'){ downCount++; p++; }

      var tokenForm = base + (upCount ? "'".repeat(upCount) : "") + (downCount ? ".".repeat(downCount) : "");
      var offset = SWARA_MAP[base];
      if(typeof offset === 'undefined'){ return { error: "Unsupported swara in run" }; }
      items.push({ base: base, offset: offset, octaveShift: upCount - downCount, token: tokenForm });
    }
    return { items: items };
  }

  // Tokenize first (handles parentheses intact and attached digits/xN)
  var tokens = tokenizeForParse(text);

  // phrase-level repetition helper
  var phraseStartIndex = 0;
  var lastGroupStart = 0;
  var lastGroupCount = 0;

  for(var i=0;i<tokens.length;i++){
    var rawTok = tokens[i];
    if(!rawTok) continue;

    // normalize m# -> M#
    var t = rawTok.replace(/m#/g,'M#');

    // pipe/phrase separator
    if(t === "|"){ phraseStartIndex = out.length; continue; }

    // rest handling: underscore optionally followed by digits
    if(/^_/.test(t)){
      var mRest = t.match(/^_([0-9]{0,2})$/);
      var beatsRest = 1;
      if(mRest && mRest[1]){ beatsRest = parseInt(mRest[1],10); }
      if(!Number.isFinite(beatsRest) || beatsRest < 0){ beatsRest = 1; }
      out.push({ token: "_", isRest: true, base: null, offset: null, octaveShift: 0, beats: beatsRest });
      lastGroupStart = out.length - 1;
      lastGroupCount = 1;
      continue;
    }

    // separate repetition token (e.g., "x3") -> repeat the phrase since last '|'
    var separateRep = t.match(/^x([0-9]+)$/i);
    if(separateRep){
      var rpt = parseInt(separateRep[1],10) || 1;
      if(rpt > 1){
        var phraseChunk = out.slice(phraseStartIndex);
        if(phraseChunk.length > 0){
          for(var r=1;r<rpt;r++){
            for(var k=0;k<phraseChunk.length;k++){
              out.push(cloneNote(phraseChunk[k]));
            }
          }
          lastGroupStart = out.length - phraseChunk.length;
          lastGroupCount = phraseChunk.length;
        }
      }
      continue;
    }

    // detect attached repetition like "(SRG)x2" or "SRMPx3"
    var repAttached = null;
    var mRepAttached = t.match(/^(.*)x([0-9]{1,3})$/i);
    if(mRepAttached){
      t = mRepAttached[1];
      repAttached = parseInt(mRepAttached[2],10) || 1;
    }

    // Parenthesis group e.g., (SRG) or (S R G) or (SRG)2 or (SRG)2x3
    var mParen = t.match(/^\(([\s\S]*)\)([0-9]{1,2})?$/); // rep attached handled above
    if(mParen){
      var inner = (mParen[1] || "").trim();
      var groupBeats = mParen[2] ? parseInt(mParen[2],10) : 1;
      if(!Number.isFinite(groupBeats) || groupBeats <= 0) groupBeats = 1;

      var parsedItems = null;

      // if inner has whitespace treat as separate tokens like "S R G"
      if(/\s+/.test(inner)){
        var innerParts = inner.split(/\s+/);
        parsedItems = [];
        var bad = false;
        for(var j=0;j<innerParts.length;j++){
          var sTok = innerParts[j].replace(/m#/g,'M#');
          var pRes = parseSingleTokenStr(sTok);
          if(pRes.error){ bad = true; break; }
          parsedItems.push(pRes);
        }
        if(bad){
          out.push(makeErrorToken(rawTok, "Unknown token inside group"));
          lastGroupStart = out.length - 1; lastGroupCount = 1;
          continue;
        }
      } else {
        // inner is a run-like string: "SRG"
        var runRes = parseRunString(inner);
        if(runRes.error){
          out.push(makeErrorToken(rawTok, runRes.error));
          lastGroupStart = out.length - 1; lastGroupCount = 1;
          continue;
        }
        parsedItems = runRes.items;
      }

      var per = groupBeats / parsedItems.length;
      var startIndex = out.length;
      for(var k=0;k<parsedItems.length;k++){
        out.push({
          token: parsedItems[k].token,
          isRest:false,
          base: parsedItems[k].base,
          offset: parsedItems[k].offset,
          octaveShift: parsedItems[k].octaveShift,
          beats: per
        });
      }
      lastGroupStart = startIndex;
      lastGroupCount = parsedItems.length;

      // handle attached repetition (if present) -> repeat only this group
      if(repAttached && repAttached > 1 && lastGroupCount > 0){
        var chunk = out.slice(lastGroupStart, lastGroupStart + lastGroupCount);
        for(var rr=1; rr<repAttached; rr++){
          for(var kk=0; kk<chunk.length; kk++){
            out.push(cloneNote(chunk[kk]));
          }
        }
        lastGroupStart = out.length - (lastGroupCount * repAttached);
        lastGroupCount = lastGroupCount * repAttached;
      }
      continue;
    }

    // Otherwise it's a run or single token (covers "S2", "G'", "SRGM2", "SRMPx3" (rep already stripped), etc.)
    // Split trailing numeric group-duration (if any)
    var mDur = t.match(/([0-9]{1,2})$/);
    var groupDuration = mDur ? parseInt(mDur[1],10) : 1;
    if(!Number.isFinite(groupDuration) || groupDuration <= 0) groupDuration = 1;
    var mainStr = mDur ? t.slice(0, -String(mDur[1]).length) : t;
    if(!mainStr){
      out.push(makeErrorToken(rawTok, "Empty token"));
      lastGroupStart = out.length - 1; lastGroupCount = 1;
      continue;
    }

    var runRes2 = parseRunString(mainStr);
    if(runRes2.error){
      out.push(makeErrorToken(rawTok, runRes2.error));
      lastGroupStart = out.length - 1; lastGroupCount = 1;
      continue;
    }
// For plain runs (SRGM), each swara gets full duration
var start = out.length;
for (var u=0; u<runRes2.items.length; u++) {
  var it2 = runRes2.items[u];
  out.push({
    token: it2.token,
    isRest: false,
    base: it2.base,
    offset: it2.offset,
    octaveShift: it2.octaveShift,
    beats: groupDuration   // << not subdivided
  });
}

    lastGroupStart = start;
    lastGroupCount = runRes2.items.length;

    // handle attached repetition (if present)
    if(repAttached && repAttached > 1 && lastGroupCount > 0){
      var chunk2 = out.slice(lastGroupStart, lastGroupStart + lastGroupCount);
      for(var rr2=1; rr2<repAttached; rr2++){
        for(var kk2=0; kk2<chunk2.length; kk2++){
          out.push(cloneNote(chunk2[kk2]));
        }
      }
      lastGroupStart = out.length - (lastGroupCount * repAttached);
      lastGroupCount = lastGroupCount * repAttached;
    }
  }

  return out;
}

// ----------------- showParsed (debug-friendly replacement) -----------------
function showParsed(){
  var txt = elSeq.value;
  var toks = tokenizeForParse(txt);
  var parsed = parseSequence(txt);
  var saMidi = midiFromNoteName(elSa.value, parseInt(elOct.value,10));
  var lines = [];
  lines.push("TOKENS: " + (toks.length ? toks.join("  |  ") : "(none)"));
  lines.push("");
  for(var i=0;i<parsed.length;i++){
    var it = parsed[i];
    if(it.error){ lines.push("? \t" + it.token + " \t→ ERROR: " + it.error); continue; }
    if(it.isRest){ lines.push("_ \t(rest) \tbeats=" + (it.beats||1)); continue; }
    var midi = saMidi + (it.offset||0) + ((it.octaveShift||0)*12);
    var freq = freqFromMidi(midi);
    if(!isFiniteNumber(freq)){ lines.push(it.token + "\t→ (skipped: bad number)"); continue; }
    var name = noteNameFromMidi(midi);
    lines.push(it.token + "\t→ " + name + " (" + freq.toFixed(2) + " Hz) \tbeats=" + (it.beats||1));
  }
  elLog.textContent = lines.join("\n");
}





// Helper: convert parsed swaras into midi/freq events (skipping errors/rests)
function toMidiEvents(parsed, saMidi){
  var events = [];
  for(var i=0;i<parsed.length;i++){
    var item = parsed[i];
    if(!item || item.isRest || item.error){ continue; }
    var midi = saMidi + item.offset + (item.octaveShift*12);
    var freq = freqFromMidi(midi);
    if(!isFiniteNumber(midi) || !isFiniteNumber(freq)){ continue; }
    events.push({ token:item.token, midi:midi, freq:freq, beats: item.beats || 1 });
  }
  return events;
}

// ===== Scheduling / Audio =====
var audioCtx = null;
var currentNodes = [];
function ensureCtx(){
  if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
}
function stopAll(){
  for(var i=0;i<currentNodes.length;i++){
    try{ currentNodes[i].stop(); }catch(e){}
    try{ currentNodes[i].disconnect && currentNodes[i].disconnect(); }catch(e){}
  }
  currentNodes = [];
}

function schedulePlay(parsed, saMidi, bpm, wave, attack, rel, gainLevel){
  ensureCtx();
  stopAll();

  // ---- sanitize numbers ----
  bpm = clamp(safeNumber(bpm, 96), 30, 240);
  var beatSec = 60 / bpm;
  var minDur = 0.03; // safety for extremely short durations
  var a = clamp(safeNumber(attack, 0.02), 0, 1);
  var r = clamp(safeNumber(rel, 0.12), 0, 2);
  var g = clamp(safeNumber(gainLevel, 0.25), 0, 1);

  var baseTime = audioCtx.currentTime + 0.06; // slight delay for scheduling
  if(audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(e){} }

  var t = baseTime;
  for(var i=0;i<parsed.length;i++){
    var item = parsed[i];
    var beats = (item && Number.isFinite(item.beats)) ? item.beats : 1;
    var dur = Math.max(minDur, beats * beatSec);

    if(!item || item.error){ t += dur; continue; }
    if(item.isRest){ t += dur; continue; }

    var midi = saMidi + item.offset + (item.octaveShift*12);
    var freq = freqFromMidi(midi);
    if(!isFiniteNumber(freq)){ t += dur; continue; } // skip bad tokens safely

    var osc = audioCtx.createOscillator();
    osc.type = wave;
    osc.frequency.setValueAtTime(freq, t);

    var amp = audioCtx.createGain();
    var start = t;
    var end = t + dur;

    // Envelope safety: ensure times are strictly increasing
    var attackEnd = start + Math.max(0.005, a);
    var releaseStart = Math.max(start + 0.01, end - Math.max(0.01, r));

    amp.gain.setValueAtTime(0.0001, start);
    amp.gain.exponentialRampToValueAtTime(Math.max(0.0002, g), attackEnd);
    amp.gain.setValueAtTime(Math.max(0.0002, g), releaseStart);
    amp.gain.exponentialRampToValueAtTime(0.0001, end);

    osc.connect(amp);
    amp.connect(audioCtx.destination);

    osc.start(start);
    osc.stop(end + 0.02);

    currentNodes.push(osc);
    t = end;
  }
}

// ===== UI wiring =====
var elSeq = document.getElementById('seq');
var elSa = document.getElementById('saNote');
var elOct = document.getElementById('saOct');
var elBpm = document.getElementById('bpm');
var elWave = document.getElementById('wave');
var elA = document.getElementById('attack');
var elR = document.getElementById('release');
var elG = document.getElementById('gain');
var elLog = document.getElementById('log');
var elStatus = document.getElementById('status');

function setStatus(text){ elStatus.textContent = text; }
function showParsed(){
  var parsed = parseSequence(elSeq.value);
  var saMidi = midiFromNoteName(elSa.value, parseInt(elOct.value,10));
  var lines = [];
  for(var i=0;i<parsed.length;i++){
    var it = parsed[i];
    if(it.error){ lines.push("? \t"+it.token+" \t→ ERROR: "+it.error); continue; }
    if(it.isRest){ lines.push("_ \t(rest) \tbeats="+(it.beats||1)); continue; }
    var midi = saMidi + it.offset + (it.octaveShift*12);
    var freq = freqFromMidi(midi);
    if(!isFiniteNumber(freq)){ lines.push(it.token+"\t→ (skipped: bad number)"); continue; }
    var name = noteNameFromMidi(midi);
    lines.push(it.token+"\t→ " + name + " ("+freq.toFixed(2)+" Hz)\tbeats="+(it.beats||1));
  }
  elLog.textContent = lines.join("\n");
}

function noteNameFromMidi(m){
  var n = ((m % 12)+12)%12;
  var oct = Math.floor(m/12) - 1;
  return WEST_NOTES[n]+oct;
}

function copyWestern(){
  var parsed = parseSequence(elSeq.value);
  var saMidi = midiFromNoteName(elSa.value, parseInt(elOct.value,10));
  var names = [];
  for(var i=0;i<parsed.length;i++){
    var it = parsed[i];
    if(it.isRest){ names.push("rest"+(it.beats>1?"("+it.beats+")":"")); continue; }
    if(it.error){ names.push("?"); continue; }
    var midi = saMidi + it.offset + (it.octaveShift*12);
    if(!isFiniteNumber(midi)){ continue; }
    names.push(noteNameFromMidi(midi) + (it.beats>1?"("+it.beats+")":""));
  }
  var txt = names.join(" ");
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(txt).then(function(){ setStatus("Copied Western notes"); }, function(){ setStatus("Clipboard blocked by browser"); });
  } else {
    setStatus("Clipboard API unavailable");
  }
}

function sanitizeInputsFromUI(){
  var oct = parseInt(elOct.value,10);
  var saMidi = midiFromNoteName(elSa.value, oct);
  var bpm = clamp(safeNumber(elBpm.value, 96), 30, 240);
  var wave = elWave.value;
  var a = clamp(safeNumber(elA.value, 0.02), 0, 1);
  var r = clamp(safeNumber(elR.value, 0.12), 0, 2);
  var g = clamp(safeNumber(elG.value, 0.25), 0, 1);

  // Reflect sanitized values back to inputs (prevents NaN from user clears)
  elBpm.value = bpm; elA.value = a; elR.value = r; elG.value = g;

  return { saMidi: saMidi, bpm: bpm, wave: wave, a: a, r: r, g: g };
}

function play(){
  var parsed = parseSequence(elSeq.value);
  if(!parsed.length){ setStatus("Nothing to play"); elLog.textContent = ""; return; }

  var cfg = sanitizeInputsFromUI();
  showParsed();
  schedulePlay(parsed, cfg.saMidi, cfg.bpm, cfg.wave, cfg.a, cfg.r, cfg.g);
  setStatus("Playing");
}

function stop(){ stopAll(); setStatus("Stopped"); }
function clearAll(){ elSeq.value = ""; elLog.textContent=""; setStatus("Cleared"); }

// Demo examples (unchanged)
function setupExamples(){
  document.getElementById('ex1').onclick = function(){
    elSeq.value = "S R G P D S' | S' D P G R S"; showParsed();
  };
  document.getElementById('ex2').onclick = function(){
    elSeq.value = "S r g M# P d n S' | S' n d P M# g r S"; showParsed();
  };
  document.getElementById('ex3').onclick = function(){
    elSeq.value = "S2 R G G M2 P _ R2 G M P2"; showParsed();
  };
}

// ===== Simple tests =====
function runTests(){
  var results = [];
  function pass(name){ results.push("✅ "+name); }
  function fail(name, msg){ results.push("❌ "+name+ (msg?" — "+msg:"")); }

  try{
    // T1: Basic parse → midi events are finite
    var seq1 = "S R G M P D N S'";
    var p1 = parseSequence(seq1);
    var events1 = toMidiEvents(p1, midiFromNoteName('C',4));
    var allFinite = events1.every(function(e){ return isFiniteNumber(e.midi) && isFiniteNumber(e.freq); });
    allFinite ? pass("T1 midi/freq finite for basic scale") : fail("T1", "non-finite values");

    // T2: Unknown tokens should be skipped, not crash
    var seq2 = "S X Y Z | R";
    var p2 = parseSequence(seq2);
    var events2 = toMidiEvents(p2, midiFromNoteName('C',4));
    (events2.length === 2) ? pass("T2 unknown tokens skipped") : fail("T2", "expected 2 playable tokens");

    // T3: BPM=0 or blank → sanitized to within [30,240]
    var oldBpm = elBpm.value; elBpm.value = "";
    var cfg3 = sanitizeInputsFromUI();
    (cfg3.bpm >= 30 && cfg3.bpm <= 240) ? pass("T3 bpm sanitized when blank") : fail("T3", "bpm not sanitized");
    elBpm.value = 0; var cfg3b = sanitizeInputsFromUI();
    (cfg3b.bpm >= 30) ? pass("T3b bpm sanitized when 0") : fail("T3b", "bpm not clamped");
    elBpm.value = oldBpm;

    // T4: Empty gain → default used (0.25)
    var oldGain = elG.value; elG.value = ""; var cfg4 = sanitizeInputsFromUI();
    (Math.abs(cfg4.g - 0.25) < 1e-6) ? pass("T4 gain fallback when blank") : fail("T4", "gain fallback failed");
    elG.value = oldGain;

    // T5: midiFromNoteName invalid name → fallback to C4 (60)
    (midiFromNoteName('H',4) === 60) ? pass("T5 invalid note name fallback") : fail("T5", "expected MIDI 60");

    // T6: Parser with octave marks and durations produces finite events
    var seq6 = "S' R. G2 M#'2 _2 P D' n. N2";
    var p6 = parseSequence(seq6);
    var ev6 = toMidiEvents(p6, midiFromNoteName('D',3));
    ev6.length > 0 && ev6.every(function(e){ return isFiniteNumber(e.midi) && isFiniteNumber(e.freq) })
      ? pass("T6 octave & durations finite") : fail("T6", "bad event detected");

  }catch(ex){
    fail("Tests crashed", String(ex && ex.message || ex));
  }

  elLog.textContent = results.join("\n");
  setStatus("Tests finished");
}

// Wire buttons
function initNotes(){
  for(var i=0;i<WEST_NOTES.length;i++){
    var op = document.createElement('option');
    op.value = WEST_NOTES[i];
    op.textContent = WEST_NOTES[i];
    elSa.appendChild(op);
  }
  elSa.value = "C";
}

initNotes();
setupExamples();
document.getElementById('play').onclick = play;
document.getElementById('stop').onclick = stop;
document.getElementById('clear').onclick = clearAll;
document.getElementById('showParsed').onclick = showParsed;
document.getElementById('copyWestern').onclick = copyWestern;
document.getElementById('runTests').onclick = runTests;

// Prefill
elSeq.value = "S R G M P D N S' | S' N D P M G R S";
showParsed();
</script>
</body>
</html>
